# オーケストレーター

複雑なタスクを順次実行されるステップに分割し、各ステップには複数の並列サブタスクを含めることができます。

## プロセス

1. **初期分析**
   - まず、タスク全体を分析してスコープと要件を理解する
   - 依存関係と実行順序を特定する
   - 依存関係に基づいて順次ステップを計画する

2. **ステップ計画**
   - 2〜4つの順次ステップに分解する
   - 各ステップには複数の並列サブタスクを含めることができる
   - 前のステップからどのようなコンテキストが必要かを定義する

3. **ステップごとの実行**
   - ステップ内のすべてのサブタスクを並列実行する
   - 現在のステップのすべてのサブタスクが完了するまで待つ
   - 関連する結果を次のステップに渡す
   - 各サブタスクから簡潔な要約（100〜200語）をリクエストする

4. **ステップのレビューと適応**
   - 各ステップ完了後、結果をレビューする
   - 残りのステップがまだ適切かを検証する
   - 発見事項に基づいて次のステップを調整する
   - 必要に応じてサブタスクを追加、削除、変更する

5. **段階的な集約**
   - 完了したステップの結果を統合する
   - 統合した結果を次のステップのコンテキストとして使用する
   - 段階的に包括的な理解を構築する
   - 計画を適応させる柔軟性を維持する

## 使用例

「テストとリントを分析してコミット」というタスクの場合：

**ステップ1：初期分析**（1つのサブタスク）
- プロジェクト構造を分析してテスト/リントのセットアップを理解する

**ステップ2：品質チェック**（並列サブタスク）
- テストを実行して結果を取得する
- リントと型チェックを実行する
- gitのステータスと変更を確認する

**ステップ3：問題の修正**（並列サブタスク、ステップ2の結果を使用）
- ステップ2で見つかったリントエラーを修正する
- ステップ2で見つかった型エラーを修正する
- 変更に基づいてコミットメッセージを準備する
*レビュー：ステップ2でエラーが見つからなかった場合、修正をスキップしてコミットに進む*

**ステップ4：最終検証**（並列サブタスク）
- 修正が機能することを確認するためテストを再実行する
- すべての問題が解決されたことを確認するためリントを再実行する
- 検証済みの変更でコミットを作成する
*レビュー：ステップ3で修正がなかった場合、単にコミットを作成するだけに簡略化*

## 主な利点

- **順次ロジック**：ステップは順番に実行され、後のステップが前の結果を使用できる
- **並列効率**：各ステップ内で、独立したタスクが同時に実行される
- **メモリ最適化**：各サブタスクは最小限のコンテキストを取得し、オーバーフローを防ぐ
- **段階的な理解**：ステップ全体で知識を段階的に構築する
- **明確な依存関係**：分析→実行→検証への明示的なフロー

## 実装上の注意

- 常に単一の分析タスクから始めて、完全なスコープを理解する
- 関連する並列タスクを同じステップ内にグループ化する
- ステップ間では重要な発見事項のみを渡す（完全な出力ではなく要約）
- TodoWriteを使用してステップとサブタスクの両方を追跡し、可視性を確保する
- 各ステップの後、明示的に計画を再検討する：
  - 次のステップはまだ関連性があるか？
  - 新しいタスクが必要な何かを発見したか？
  - 今後のステップをスキップまたは簡略化できるか？
  - 新しい検証ステップを追加すべきか？

## 適応的計画の例

```
初期計画：ステップ1 → ステップ2 → ステップ3 → ステップ4

ステップ2後：「テストまたはリントでエラーが見つからなかった」
適応後の計画：ステップ1 → ステップ2 → ステップ3をスキップ → 簡略化されたステップ4（コミットのみ）

ステップ2後：「重大なアーキテクチャの問題が見つかった」
適応後の計画：ステップ1 → ステップ2 → 新しいステップ2.5（アーキテクチャを分析）→ 変更されたステップ3
```